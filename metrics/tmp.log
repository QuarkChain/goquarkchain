ewma_test.go:3:import "testing"
ewma_test.go-4-
ewma_test.go-5-func BenchmarkEWMA(b *testing.B) {
ewma_test.go-6-	a := NewEWMA1()
ewma_test.go-7-	b.ResetTimer()
ewma_test.go-8-	for i := 0; i < b.N; i++ {
ewma_test.go-9-		a.Update(1)
ewma_test.go-10-		a.Tick()
ewma_test.go-11-	}
ewma_test.go-12-}
ewma_test.go-13-
--
syslog.go:5:import (
syslog.go-6-	"fmt"
syslog.go-7-	"log/syslog"
syslog.go-8-	"time"
syslog.go-9-)
syslog.go-10-
syslog.go-11-// Output each metric in the given registry to syslog periodically using
syslog.go-12-// the given syslogger.
syslog.go-13-func Syslog(r Registry, d time.Duration, w *syslog.Writer) {
syslog.go-14-	for range time.Tick(d) {
syslog.go-15-		r.Each(func(name string, i interface{}) {
--
timer_test.go:3:import (
timer_test.go-4-	"fmt"
timer_test.go-5-	"math"
timer_test.go-6-	"testing"
timer_test.go-7-	"time"
timer_test.go-8-)
timer_test.go-9-
timer_test.go-10-func BenchmarkTimer(b *testing.B) {
timer_test.go-11-	tm := NewTimer()
timer_test.go-12-	b.ResetTimer()
timer_test.go-13-	for i := 0; i < b.N; i++ {
--
runtime_test.go:3:import (
runtime_test.go-4-	"runtime"
runtime_test.go-5-	"testing"
runtime_test.go-6-	"time"
runtime_test.go-7-)
runtime_test.go-8-
runtime_test.go-9-func BenchmarkRuntimeMemStats(b *testing.B) {
runtime_test.go-10-	r := NewRegistry()
runtime_test.go-11-	RegisterRuntimeMemStats(r)
runtime_test.go-12-	b.ResetTimer()
runtime_test.go-13-	for i := 0; i < b.N; i++ {
--
metrics.go:8:import (
metrics.go-9-	"os"
metrics.go-10-	"runtime"
metrics.go-11-	"strings"
metrics.go-12-	"time"
metrics.go-13-
metrics.go-14-	"github.com/ethereum/go-ethereum/log"
metrics.go-15-)
metrics.go-16-
metrics.go-17-// Enabled is checked by the constructor functions for all of the
metrics.go-18-// standard metrics.  If it is true, the metric returned is a stub.
--
counter.go:3:import (
counter.go-4-	"sync/atomic"
counter.go-5-)
counter.go-6-
counter.go-7-// Counters hold an int64 value that can be incremented and decremented.
counter.go-8-type Counter interface {
counter.go-9-	Clear()
counter.go-10-	Count() int64
counter.go-11-	Dec(int64)
counter.go-12-	Inc(int64)
counter.go-13-	Snapshot() Counter
--
gauge_test.go:3:import (
gauge_test.go-4-	"fmt"
gauge_test.go-5-	"testing"
gauge_test.go-6-)
gauge_test.go-7-
gauge_test.go-8-func BenchmarkGuage(b *testing.B) {
gauge_test.go-9-	g := NewGauge()
gauge_test.go-10-	b.ResetTimer()
gauge_test.go-11-	for i := 0; i < b.N; i++ {
gauge_test.go-12-		g.Update(int64(i))
gauge_test.go-13-	}
--
debug_test.go:3:import (
debug_test.go-4-	"runtime"
debug_test.go-5-	"runtime/debug"
debug_test.go-6-	"testing"
debug_test.go-7-	"time"
debug_test.go-8-)
debug_test.go-9-
debug_test.go-10-func BenchmarkDebugGCStats(b *testing.B) {
debug_test.go-11-	r := NewRegistry()
debug_test.go-12-	RegisterDebugGCStats(r)
debug_test.go-13-	b.ResetTimer()
--
gauge_float64.go:3:import "sync"
gauge_float64.go-4-
gauge_float64.go-5-// GaugeFloat64s hold a float64 value that can be set arbitrarily.
gauge_float64.go-6-type GaugeFloat64 interface {
gauge_float64.go-7-	Snapshot() GaugeFloat64
gauge_float64.go-8-	Update(float64)
gauge_float64.go-9-	Value() float64
gauge_float64.go-10-}
gauge_float64.go-11-
gauge_float64.go-12-// GetOrRegisterGaugeFloat64 returns an existing GaugeFloat64 or constructs and registers a
gauge_float64.go-13-// new StandardGaugeFloat64.
--
sample_test.go:3:import (
sample_test.go-4-	"math/rand"
sample_test.go-5-	"runtime"
sample_test.go-6-	"testing"
sample_test.go-7-	"time"
sample_test.go-8-)
sample_test.go-9-
sample_test.go-10-// Benchmark{Compute,Copy}{1000,1000000} demonstrate that, even for relatively
sample_test.go-11-// expensive computations like Variance, the cost of copying the Sample, as
sample_test.go-12-// approximated by a make and copy, is much greater than the cost of the
sample_test.go-13-// computation for small samples and only slightly less for large samples.
--
meter_test.go:3:import (
meter_test.go-4-	"testing"
meter_test.go-5-	"time"
meter_test.go-6-)
meter_test.go-7-
meter_test.go-8-func BenchmarkMeter(b *testing.B) {
meter_test.go-9-	m := NewMeter()
meter_test.go-10-	b.ResetTimer()
meter_test.go-11-	for i := 0; i < b.N; i++ {
meter_test.go-12-		m.Mark(1)
meter_test.go-13-	}
--
README.md:78:import "github.com/cyberdelia/go-metrics-graphite"
README.md-79-
README.md-80-addr, _ := net.ResolveTCPAddr("tcp", "127.0.0.1:2003")
README.md-81-go graphite.Graphite(metrics.DefaultRegistry, 10e9, "metrics", addr)
README.md-82-```
README.md-83-
README.md-84-Periodically emit every metric into InfluxDB:
README.md-85-
README.md-86-**NOTE:** this has been pulled out of the library due to constant fluctuations
README.md-87-in the InfluxDB API. In fact, all client libraries are on their way out. see
README.md-88-issues [#121](https://github.com/rcrowley/go-metrics/issues/121) and
--
README.md:92:import "github.com/vrischmann/go-metrics-influxdb"
README.md-93-
README.md-94-go influxdb.InfluxDB(metrics.DefaultRegistry,
README.md-95-  10e9, 
README.md-96-  "127.0.0.1:8086", 
README.md-97-  "database-name", 
README.md-98-  "username", 
README.md-99-  "password"
README.md-100-)
README.md-101-```
README.md-102-
--
README.md:109:import "github.com/mihasya/go-metrics-librato"
README.md-110-
README.md-111-go librato.Librato(metrics.DefaultRegistry,
README.md-112-    10e9,                  // interval
README.md-113-    "example@example.com", // account owner email address
README.md-114-    "token",               // Librato API token
README.md-115-    "hostname",            // source
README.md-116-    []float64{0.95},       // percentiles to send
README.md-117-    time.Millisecond,      // time unit
README.md-118-)
README.md-119-```
--
README.md:124:import "github.com/rcrowley/go-metrics/stathat"
README.md-125-
README.md-126-go stathat.Stathat(metrics.DefaultRegistry, 10e9, "example@example.com")
README.md-127-```
README.md-128-
README.md-129-Maintain all metrics along with expvars at `/debug/metrics`:
README.md-130-
README.md-131-This uses the same mechanism as [the official expvar](http://golang.org/pkg/expvar/)
README.md-132-but exposed under `/debug/metrics`, which shows a json representation of all your usual expvars
README.md-133-as well as all your go-metrics.
README.md-134-
--
README.md:137:import "github.com/rcrowley/go-metrics/exp"
README.md-138-
README.md-139-exp.Exp(metrics.DefaultRegistry)
README.md-140-```
README.md-141-
README.md-142-Installation
README.md-143-------------
README.md-144-
README.md-145-```sh
README.md-146-go get github.com/rcrowley/go-metrics
README.md-147-```
--
log.go:3:import (
log.go-4-	"time"
log.go-5-)
log.go-6-
log.go-7-type Logger interface {
log.go-8-	Printf(format string, v ...interface{})
log.go-9-}
log.go-10-
log.go-11-func Log(r Registry, freq time.Duration, l Logger) {
log.go-12-	LogScaled(r, freq, time.Nanosecond, l)
log.go-13-}
--
graphite_test.go:3:import (
graphite_test.go-4-	"net"
graphite_test.go-5-	"time"
graphite_test.go-6-)
graphite_test.go-7-
graphite_test.go-8-func ExampleGraphite() {
graphite_test.go-9-	addr, _ := net.ResolveTCPAddr("net", ":2003")
graphite_test.go-10-	go Graphite(DefaultRegistry, 1*time.Second, "some.prefix", addr)
graphite_test.go-11-}
graphite_test.go-12-
graphite_test.go-13-func ExampleGraphiteWithConfig() {
--
meter.go:3:import (
meter.go-4-	"sync"
meter.go-5-	"time"
meter.go-6-)
meter.go-7-
meter.go-8-// Meters count events to produce exponentially-weighted moving average rates
meter.go-9-// at one-, five-, and fifteen-minutes and a mean rate.
meter.go-10-type Meter interface {
meter.go-11-	Count() int64
meter.go-12-	Mark(int64)
meter.go-13-	Rate1() float64
--
gauge_float64_test.go:3:import "testing"
gauge_float64_test.go-4-
gauge_float64_test.go-5-func BenchmarkGuageFloat64(b *testing.B) {
gauge_float64_test.go-6-	g := NewGaugeFloat64()
gauge_float64_test.go-7-	b.ResetTimer()
gauge_float64_test.go-8-	for i := 0; i < b.N; i++ {
gauge_float64_test.go-9-		g.Update(float64(i))
gauge_float64_test.go-10-	}
gauge_float64_test.go-11-}
gauge_float64_test.go-12-
gauge_float64_test.go-13-func TestGaugeFloat64(t *testing.T) {
--
writer_test.go:3:import (
writer_test.go-4-	"sort"
writer_test.go-5-	"testing"
writer_test.go-6-)
writer_test.go-7-
writer_test.go-8-func TestMetricsSorting(t *testing.T) {
writer_test.go-9-	var namedMetrics = namedMetricSlice{
writer_test.go-10-		{name: "zzz"},
writer_test.go-11-		{name: "bbb"},
writer_test.go-12-		{name: "fff"},
writer_test.go-13-		{name: "ggg"},
--
runtime.go:3:import (
runtime.go-4-	"runtime"
runtime.go-5-	"runtime/pprof"
runtime.go-6-	"time"
runtime.go-7-)
runtime.go-8-
runtime.go-9-var (
runtime.go-10-	memStats       runtime.MemStats
runtime.go-11-	runtimeMetrics struct {
runtime.go-12-		MemStats struct {
runtime.go-13-			Alloc         Gauge
--
json_test.go:3:import (
json_test.go-4-	"bytes"
json_test.go-5-	"encoding/json"
json_test.go-6-	"testing"
json_test.go-7-)
json_test.go-8-
json_test.go-9-func TestRegistryMarshallJSON(t *testing.T) {
json_test.go-10-	b := &bytes.Buffer{}
json_test.go-11-	enc := json.NewEncoder(b)
json_test.go-12-	r := NewRegistry()
json_test.go-13-	r.Register("counter", NewCounter())
--
opentsdb_test.go:3:import (
opentsdb_test.go-4-	"net"
opentsdb_test.go-5-	"time"
opentsdb_test.go-6-)
opentsdb_test.go-7-
opentsdb_test.go-8-func ExampleOpenTSDB() {
opentsdb_test.go-9-	addr, _ := net.ResolveTCPAddr("net", ":2003")
opentsdb_test.go-10-	go OpenTSDB(DefaultRegistry, 1*time.Second, "some.prefix", addr)
opentsdb_test.go-11-}
opentsdb_test.go-12-
opentsdb_test.go-13-func ExampleOpenTSDBWithConfig() {
--
graphite.go:3:import (
graphite.go-4-	"bufio"
graphite.go-5-	"fmt"
graphite.go-6-	"log"
graphite.go-7-	"net"
graphite.go-8-	"strconv"
graphite.go-9-	"strings"
graphite.go-10-	"time"
graphite.go-11-)
graphite.go-12-
graphite.go-13-// GraphiteConfig provides a container with configuration parameters for
--
influxdb/README.md:15:import "github.com/vrischmann/go-metrics-influxdb"
influxdb/README.md-16-
influxdb/README.md-17-go influxdb.InfluxDB(
influxdb/README.md-18-    metrics.DefaultRegistry, // metrics registry
influxdb/README.md-19-    time.Second * 10,        // interval
influxdb/README.md-20-    "http://localhost:8086", // the InfluxDB url
influxdb/README.md-21-    "mydb",                  // your InfluxDB database
influxdb/README.md-22-    "myuser",                // your InfluxDB user
influxdb/README.md-23-    "mypassword",            // your InfluxDB password
influxdb/README.md-24-)
influxdb/README.md-25-```
--
influxdb/influxdb.go:3:import (
influxdb/influxdb.go-4-	"fmt"
influxdb/influxdb.go-5-	uurl "net/url"
influxdb/influxdb.go-6-	"time"
influxdb/influxdb.go-7-
influxdb/influxdb.go-8-	"github.com/ethereum/go-ethereum/log"
influxdb/influxdb.go-9-	"github.com/ethereum/go-ethereum/metrics"
influxdb/influxdb.go-10-	"github.com/influxdata/influxdb/client"
influxdb/influxdb.go-11-)
influxdb/influxdb.go-12-
influxdb/influxdb.go-13-type reporter struct {
--
disk_nop.go:21:import "errors"
disk_nop.go-22-
disk_nop.go-23-// ReadDiskStats retrieves the disk IO stats belonging to the current process.
disk_nop.go-24-func ReadDiskStats(stats *DiskStats) error {
disk_nop.go-25-	return errors.New("Not implemented")
disk_nop.go-26-}
--
json.go:3:import (
json.go-4-	"encoding/json"
json.go-5-	"io"
json.go-6-	"time"
json.go-7-)
json.go-8-
json.go-9-// MarshalJSON returns a byte slice containing a JSON representation of all
json.go-10-// the metrics in the Registry.
json.go-11-func (r *StandardRegistry) MarshalJSON() ([]byte, error) {
json.go-12-	return json.Marshal(r.GetAll())
json.go-13-}
--
runtime_cgo.go:6:import "runtime"
runtime_cgo.go-7-
runtime_cgo.go-8-func numCgoCall() int64 {
runtime_cgo.go-9-	return runtime.NumCgoCall()
runtime_cgo.go-10-}
--
resetting_timer.go:3:import (
resetting_timer.go-4-	"math"
resetting_timer.go-5-	"sort"
resetting_timer.go-6-	"sync"
resetting_timer.go-7-	"time"
resetting_timer.go-8-)
resetting_timer.go-9-
resetting_timer.go-10-// Initial slice capacity for the values stored in a ResettingTimer
resetting_timer.go-11-const InitialResettingTimerSliceCap = 10
resetting_timer.go-12-
resetting_timer.go-13-// ResettingTimer is used for storing aggregated values for timers, which are reset on every flush interval.
--
memory.md:17:import "time"
memory.md-18-
memory.md-19-func main() {
memory.md-20-	time.Sleep(600e9)
memory.md-21-}
memory.md-22-```
memory.md-23-
memory.md-24-Baseline
memory.md-25---------
memory.md-26-
memory.md-27-```
--
memory.md:46:import (
memory.md-47-	"fmt"
memory.md-48-	"metrics"
memory.md-49-	"time"
memory.md-50-)
memory.md-51-
memory.md-52-func main() {
memory.md-53-	fmt.Sprintf("foo")
memory.md-54-	metrics.NewRegistry()
memory.md-55-	time.Sleep(600e9)
memory.md-56-}
--
librato/client.go:3:import (
librato/client.go-4-	"bytes"
librato/client.go-5-	"encoding/json"
librato/client.go-6-	"fmt"
librato/client.go-7-	"io/ioutil"
librato/client.go-8-	"net/http"
librato/client.go-9-)
librato/client.go-10-
librato/client.go-11-const Operations = "operations"
librato/client.go-12-const OperationsShort = "ops"
librato/client.go-13-
--
librato/librato.go:3:import (
librato/librato.go-4-	"fmt"
librato/librato.go-5-	"log"
librato/librato.go-6-	"math"
librato/librato.go-7-	"regexp"
librato/librato.go-8-	"time"
librato/librato.go-9-
librato/librato.go-10-	"github.com/ethereum/go-ethereum/metrics"
librato/librato.go-11-)
librato/librato.go-12-
librato/librato.go-13-// a regexp for extracting the unit from time.Duration.String
--
sample.go:3:import (
sample.go-4-	"math"
sample.go-5-	"math/rand"
sample.go-6-	"sort"
sample.go-7-	"sync"
sample.go-8-	"time"
sample.go-9-)
sample.go-10-
sample.go-11-const rescaleThreshold = time.Hour
sample.go-12-
sample.go-13-// Samples maintain a statistically-significant selection of values from
--
counter_test.go:3:import "testing"
counter_test.go-4-
counter_test.go-5-func BenchmarkCounter(b *testing.B) {
counter_test.go-6-	c := NewCounter()
counter_test.go-7-	b.ResetTimer()
counter_test.go-8-	for i := 0; i < b.N; i++ {
counter_test.go-9-		c.Inc(1)
counter_test.go-10-	}
counter_test.go-11-}
counter_test.go-12-
counter_test.go-13-func TestCounterClear(t *testing.T) {
--
debug.go:3:import (
debug.go-4-	"runtime/debug"
debug.go-5-	"time"
debug.go-6-)
debug.go-7-
debug.go-8-var (
debug.go-9-	debugMetrics struct {
debug.go-10-		GCStats struct {
debug.go-11-			LastGC Gauge
debug.go-12-			NumGC  Gauge
debug.go-13-			Pause  Histogram
--
gauge.go:3:import "sync/atomic"
gauge.go-4-
gauge.go-5-// Gauges hold an int64 value that can be set arbitrarily.
gauge.go-6-type Gauge interface {
gauge.go-7-	Snapshot() Gauge
gauge.go-8-	Update(int64)
gauge.go-9-	Value() int64
gauge.go-10-}
gauge.go-11-
gauge.go-12-// GetOrRegisterGauge returns an existing Gauge or constructs and registers a
gauge.go-13-// new StandardGauge.
--
opentsdb.go:3:import (
opentsdb.go-4-	"bufio"
opentsdb.go-5-	"fmt"
opentsdb.go-6-	"log"
opentsdb.go-7-	"net"
opentsdb.go-8-	"os"
opentsdb.go-9-	"strings"
opentsdb.go-10-	"time"
opentsdb.go-11-)
opentsdb.go-12-
opentsdb.go-13-var shortHostName string = ""
--
exp/exp.go:5:import (
exp/exp.go-6-	"expvar"
exp/exp.go-7-	"fmt"
exp/exp.go-8-	"net/http"
exp/exp.go-9-	"sync"
exp/exp.go-10-
exp/exp.go-11-	"github.com/ethereum/go-ethereum/metrics"
exp/exp.go-12-)
exp/exp.go-13-
exp/exp.go-14-type exp struct {
exp/exp.go-15-	expvarLock sync.Mutex // expvar panics if you try to register the same var twice, so we must probe it safely
--
resetting_timer_test.go:3:import (
resetting_timer_test.go-4-	"testing"
resetting_timer_test.go-5-	"time"
resetting_timer_test.go-6-)
resetting_timer_test.go-7-
resetting_timer_test.go-8-func TestResettingTimer(t *testing.T) {
resetting_timer_test.go-9-	tests := []struct {
resetting_timer_test.go-10-		values   []int64
resetting_timer_test.go-11-		start    int
resetting_timer_test.go-12-		end      int
resetting_timer_test.go-13-		wantP50  int64
--
metrics_test.go:3:import (
metrics_test.go-4-	"fmt"
metrics_test.go-5-	"io/ioutil"
metrics_test.go-6-	"log"
metrics_test.go-7-	"sync"
metrics_test.go-8-	"testing"
metrics_test.go-9-	"time"
metrics_test.go-10-)
metrics_test.go-11-
metrics_test.go-12-const FANOUT = 128
metrics_test.go-13-
--
timer.go:3:import (
timer.go-4-	"sync"
timer.go-5-	"time"
timer.go-6-)
timer.go-7-
timer.go-8-// Timers capture the duration and rate of events.
timer.go-9-type Timer interface {
timer.go-10-	Count() int64
timer.go-11-	Max() int64
timer.go-12-	Mean() float64
timer.go-13-	Min() int64
--
registry_test.go:3:import (
registry_test.go-4-	"testing"
registry_test.go-5-)
registry_test.go-6-
registry_test.go-7-func BenchmarkRegistry(b *testing.B) {
registry_test.go-8-	r := NewRegistry()
registry_test.go-9-	r.Register("foo", NewCounter())
registry_test.go-10-	b.ResetTimer()
registry_test.go-11-	for i := 0; i < b.N; i++ {
registry_test.go-12-		r.Each(func(string, interface{}) {})
registry_test.go-13-	}
--
histogram_test.go:3:import "testing"
histogram_test.go-4-
histogram_test.go-5-func BenchmarkHistogram(b *testing.B) {
histogram_test.go-6-	h := NewHistogram(NewUniformSample(100))
histogram_test.go-7-	b.ResetTimer()
histogram_test.go-8-	for i := 0; i < b.N; i++ {
histogram_test.go-9-		h.Update(int64(i))
histogram_test.go-10-	}
histogram_test.go-11-}
histogram_test.go-12-
histogram_test.go-13-func TestGetOrRegisterHistogram(t *testing.T) {
--
disk_linux.go:21:import (
disk_linux.go-22-	"bufio"
disk_linux.go-23-	"fmt"
disk_linux.go-24-	"io"
disk_linux.go-25-	"os"
disk_linux.go-26-	"strconv"
disk_linux.go-27-	"strings"
disk_linux.go-28-)
disk_linux.go-29-
disk_linux.go-30-// ReadDiskStats retrieves the disk IO stats belonging to the current process.
disk_linux.go-31-func ReadDiskStats(stats *DiskStats) error {
--
ewma.go:3:import (
ewma.go-4-	"math"
ewma.go-5-	"sync"
ewma.go-6-	"sync/atomic"
ewma.go-7-)
ewma.go-8-
ewma.go-9-// EWMAs continuously calculate an exponentially-weighted moving average
ewma.go-10-// based on an outside source of clock ticks.
ewma.go-11-type EWMA interface {
ewma.go-12-	Rate() float64
ewma.go-13-	Snapshot() EWMA
--
writer.go:3:import (
writer.go-4-	"fmt"
writer.go-5-	"io"
writer.go-6-	"sort"
writer.go-7-	"time"
writer.go-8-)
writer.go-9-
writer.go-10-// Write sorts writes each metric in the given registry periodically to the
writer.go-11-// given io.Writer.
writer.go-12-func Write(r Registry, d time.Duration, w io.Writer) {
writer.go-13-	for range time.Tick(d) {
--
runtime_gccpufraction.go:5:import "runtime"
runtime_gccpufraction.go-6-
runtime_gccpufraction.go-7-func gcCPUFraction(memStats *runtime.MemStats) float64 {
runtime_gccpufraction.go-8-	return memStats.GCCPUFraction
runtime_gccpufraction.go-9-}
--
registry.go:3:import (
registry.go-4-	"fmt"
registry.go-5-	"reflect"
registry.go-6-	"strings"
registry.go-7-	"sync"
registry.go-8-)
registry.go-9-
registry.go-10-// DuplicateMetric is the error returned by Registry.Register when a metric
registry.go-11-// already exists.  If you mean to Register that metric you must first
registry.go-12-// Unregister the existing metric.
registry.go-13-type DuplicateMetric string
--
runtime_no_gccpufraction.go:5:import "runtime"
runtime_no_gccpufraction.go-6-
runtime_no_gccpufraction.go-7-func gcCPUFraction(memStats *runtime.MemStats) float64 {
runtime_no_gccpufraction.go-8-	return 0
runtime_no_gccpufraction.go-9-}
